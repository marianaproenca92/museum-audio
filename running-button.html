<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Nó de Arquivo 23 — O Botão Fugitivo</title>
<link rel="stylesheet" href="css/style.css">
<style>
  
  #runaway-btn {
    position: fixed;                 /* instead of absolute */
    z-index: 3;                      /* above canvas/content */
    background: #111;
    color: #0f0;
    font-family: 'Cinzel', serif;
    font-size: 5vw;
    border: 1px solid #0f0;
    padding: 10px 20px;
    cursor: pointer;
    transition: transform 0.2s ease;
    max-width: calc(100vw - 40px);   /* prevent overflowing the viewport width */
    white-space: nowrap;             /* optional: keep it on one line */
  }

  #runaway-btn:hover {
    background: #0f0;
    color: #000;
  }
  audio {
    margin-top: 2em;
    width: 100%;
    max-width: 400px;
    display: none;
  }
</style>
</head>
<body>
<div id="intro"></div>

<div id="content" style="display:none;">
  <h1>Nó de Arquivo 23</h1>
  <div class="subtitle">O Botão Fugitivo</div>

  <button id="runaway-btn">Ativar Registo</button>

  <audio id="ritual-audio" controls>
    <source src="fugitivo.mp3" type="audio/mpeg">
  </audio>
</div>

<script src="js/intro.js"></script>
<script>
runGlitchIntro(initRunawayButton);

function initRunawayButton(){
  const btn = document.getElementById("runaway-btn");
  const audio = document.getElementById("ritual-audio");
  const PADDING = 20; // distance from edges

  // Make sure it's measurable
  btn.style.visibility = "hidden";
  btn.style.display = "block";

  // place after layout paints
  requestAnimationFrame(() => {
    moveButton(true);
    btn.style.visibility = "visible";
  });

  // Events
  btn.addEventListener("mouseover", () => moveButton(), { passive: true });
  btn.addEventListener("touchstart", () => moveButton(), { passive: true });

  btn.addEventListener("click", () => {
    btn.style.display = "none";
    audio.style.display = "block";
    audio.play();
  });

  // Keep it clamped on resize/orientation
  window.addEventListener("resize", () => clampToViewport());
  window.addEventListener("orientationchange", () => setTimeout(clampToViewport, 200));

  function viewportSize() {
    // visible viewport (helps on mobile address bar)
    const vw = Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
    const vh = Math.min(window.innerHeight, document.documentElement.clientHeight || window.innerHeight);
    return { vw, vh };
  }

  function measure() {
    // if not measurable yet, use conservative defaults
    const rect = btn.getBoundingClientRect();
    const w = rect.width  || btn.offsetWidth  || 200;
    const h = rect.height || btn.offsetHeight || 60;
    return { w, h };
  }

  function clampToViewport() {
    const { vw, vh } = viewportSize();
    const { w, h } = measure();

    const minX = PADDING;
    const minY = PADDING;
    const maxX = Math.max(PADDING, vw - w - PADDING);
    const maxY = Math.max(PADDING, vh - h - PADDING);

    // current position
    const rect = btn.getBoundingClientRect();
    let x = rect.left;
    let y = rect.top;

    // clamp
    x = Math.min(Math.max(x, minX), maxX);
    y = Math.min(Math.max(y, minY), maxY);

    btn.style.left = `${x}px`;
    btn.style.top  = `${y}px`;
  }

  function moveButton(initial = false) {
    const { vw, vh } = viewportSize();
    const { w, h } = measure();

    const minX = PADDING;
    const minY = PADDING;
    const maxX = Math.max(PADDING, vw - w - PADDING);
    const maxY = Math.max(PADDING, vh - h - PADDING);

    // If the button is too big (tiny screens), it will still fit due to max-width CSS,
    // but just in case, anchor it to top-left safe zone:
    if (maxX <= minX || maxY <= minY) {
      btn.style.left = `${minX}px`;
      btn.style.top  = `${minY}px`;
      return;
    }

    const newX = Math.round(minX + Math.random() * (maxX - minX));
    const newY = Math.round(minY + Math.random() * (maxY - minY));

    btn.style.left = `${newX}px`;
    btn.style.top  = `${newY}px`;

    // On first placement, ensure clamped after paint
    if (initial) requestAnimationFrame(clampToViewport);
  }
}

</script>
</body>
</html>
